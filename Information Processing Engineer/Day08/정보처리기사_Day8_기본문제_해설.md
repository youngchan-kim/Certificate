
# 📘 정보처리기사 Day 8 – 데이터베이스 관리 구조 기본 문제 해설 & 정리

## ✅ 채점 결과: 7 / 12

| 문항 | 너의 답 | 정답 | 정오 |
|------|---------|------|------|
| Q1   | 2       | 2    | ✅ |
| Q2   | 3       | 3    | ✅ |
| Q3   | 2       | 3    | ❌ |
| Q4   | 1       | 1    | ✅ |
| Q5   | 3       | 3    | ✅ |
| Q6   | 3       | 2    | ❌ |
| Q7   | 2       | 4    | ❌ |
| Q8   | 1       | 3    | ❌ |
| Q9   | 2       | 2    | ✅ |
| Q10  | 3       | 3    | ✅ |
| Q11  | 1       | 1    | ✅ |
| Q12  | 2       | 1    | ❌ |

---

## ❌ 틀린 문제 상세 해설

### Q3. COMMIT 이후 가능한 작업
- 너의 답: 2 (데이터 복원)
- 정답: 3 (**변경 내용 확정**)  
- 해설: COMMIT은 **트랜잭션을 완료**하고 데이터를 **영구 저장**함 → 이후 ROLLBACK이나 복원 ❌ 불가

---

### Q6. COMMIT되지 않은 값을 읽는 현상
- 너의 답: 3 (Phantom Read)
- 정답: 2 (**Dirty Read**)  
- 해설: **Dirty Read**는 아직 COMMIT되지 않은 데이터를 읽는 현상

---

### Q7. 같은 SELECT 결과가 다르게 나오는 현상
- 너의 답: 2 (Dirty Read)
- 정답: 4 (**Non-repeatable Read**)  
- 해설: 동일한 SELECT를 두 번 했는데 값이 변경된 경우 = **반복 불가능한 읽기**

---

### Q8. PRIMARY KEY 제약조건
- 너의 답: 1 (중복 허용)
- 정답: 3 (**유일성 + NOT NULL** 모두 만족해야 함)  
- 해설: PRIMARY KEY는 **반드시 고유하고 NULL 불가**

---

### Q12. 이전 상태로 되돌리는 회복 기법
- 너의 답: 2 (REDO)
- 정답: 1 (**ROLLBACK**)  
- 해설: UNDO 또는 ROLLBACK은 변경 전 상태로 복구하는 것  
→ REDO는 COMMIT된 내용을 **다시 반영**하는 것임

---

## ✅ 맞은 문제 요약 정리

### Q1. 트랜잭션 특성 – 독립성 (Isolation)
- 트랜잭션은 독립적으로 수행되어야 함

### Q2. 원자성 – 전부 성공 또는 실패 (ALL or NOTHING)

### Q4. SAVEPOINT – 트랜잭션 중간 저장점 설정

### Q5. 병행 제어 목적 – 트랜잭션의 **일관성과 독립성 보장**

### Q9. FOREIGN KEY – 참조키는 **다른 테이블의 PK를 가리킴**

### Q10. CHECK – **조건을 만족하는 값만 입력 가능**

### Q11. REDO – COMMIT된 트랜잭션을 다시 반영

---

✅ 위 내용을 기반으로 다음은 **회복과 병행 제어 실전 응용 문제**로 넘어갈 수 있어.
